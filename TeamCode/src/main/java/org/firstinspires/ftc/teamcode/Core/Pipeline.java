package org.firstinspires.ftc.teamcode.Core;

import org.opencv.core.*;
//import org.opencv.features2d.FeatureDetector;
import org.opencv.imgproc.*;
import org.openftc.easyopencv.OpenCvPipeline;

/**
 * Pipeline class.
 *
 * <p>An OpenCV pipeline generated by GRIP.
 * Has filters for green, orange, and purple.
 *
 *
 * @author GRIP
 */
public class Pipeline extends OpenCvPipeline {
    private Mat webcamOutput = new Mat();
    private Mat hsvFilterGreen = new Mat();
    private Mat hsvFilterOrange = new Mat();
    private Mat hsvFilterPurple = new Mat();

    static {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
    }

    /**
     * This is the primary method that runs the entire pipeline and updates the outputs.
     */
    public Mat processFrame(Mat source0) {
        // Flip webcam on x and y axes
        Mat cvFlipSrc = source0;
        FlipCode cvFlipFlipcode = FlipCode.BOTH_AXES;
        cvFlip(cvFlipSrc, cvFlipFlipcode, webcamOutput);

        // Filter webcam to only view green (turned into black/white mesh)
        Mat hsvFilterGreenInput = webcamOutput;
        double[] hsvFilterGreenHue = {42.086330935251794, 80.17064846416382};
        double[] hsvFilterGreenSaturation = {107.77877697841724, 255.0};
        double[] hsvFilterGreenValue = {94.01978417266186, 255.0};
        hsvThreshold(hsvFilterGreenInput, hsvFilterGreenHue, hsvFilterGreenSaturation, hsvFilterGreenValue, hsvFilterGreen);

        // Filter webcam to only view orange (turned into black/white mesh)
        Mat hsvFilterOrangeInput = webcamOutput;
        double[] hsvFilterOrangeHue = {8.093525179856115, 19.034459980182742};
        double[] hsvFilterOrangeSaturation = {127.68742633012235, 255.0};
        double[] hsvFilterOrangeValue = {121.53776978417267, 255.0};
        hsvThreshold(hsvFilterOrangeInput, hsvFilterOrangeHue, hsvFilterOrangeSaturation, hsvFilterOrangeValue, hsvFilterOrange);

        // Filter webcam to only view purple (turned into black/white mesh)
        Mat hsvFilterPurpleInput = webcamOutput;
        double[] hsvFilterPurpleHue = {121.40287769784173, 180.0};
        double[] hsvFilterPurpleSaturation = {144.46942446043167, 255.0};
        double[] hsvFilterPurpleValue = {61.915467625899275, 255.0};
        hsvThreshold(hsvFilterPurpleInput, hsvFilterPurpleHue, hsvFilterPurpleSaturation, hsvFilterPurpleValue, hsvFilterPurple);

        //obligatory; not very useful
        return webcamOutput;
    }

    /** Returns image of webcam after it was flipped on the x and y axes */
    public Mat getWebcamOutput() {
        return webcamOutput;
    }

    /**
     * This method is a generated getter for the output of a HSV_Threshold.
     * @return Mat output from HSV_Threshold.
     */
    public Mat getHsvFilterGreen() {
        return hsvFilterGreen;
    }

    /**
     * This method is a generated getter for the output of a HSV_Threshold.
     * @return Mat output from HSV_Threshold.
     */
    public Mat getHsvFilterOrange() {
        return hsvFilterOrange;
    }

    /**
     * This method is a generated getter for the output of a HSV_Threshold.
     * @return Mat output from HSV_Threshold.
     */
    public Mat getHsvFilterPurple() {
        return hsvFilterPurple;
    }


    /**
     * Code used for CV_flip.
     * Per OpenCV spec 0 -> flip on X axis.
     * >0 -> flip on Y axis.
     * <0 -> flip on both axes.
     */
    public enum FlipCode {
        X_AXIS(0),
        Y_AXIS(1),
        BOTH_AXES(-1);
        public final int value;
        FlipCode(int value) {
            this.value = value;
        }
    }

    /**
     * Flips an image along X, Y or both axes.
     * @param src Image to flip.
     * @param flipcode FlipCode of which direction to flip.
     * @param dst flipped version of the Image.
     */
    private void cvFlip(Mat src, FlipCode flipcode, Mat dst) {
        Core.flip(src, dst, flipcode.value);
    }

    /**
     * Segment an image based on hue, saturation, and value ranges.
     *
     * @param input The image on which to perform the HSL threshold.
     * @param hue The min and max hue
     * @param sat The min and max saturation
     * @param val The min and max value
     * @param out The image in which to store the output.
     */
    private void hsvThreshold(Mat input, double[] hue, double[] sat, double[] val,
                              Mat out) {
        Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HSV);
        Core.inRange(out, new Scalar(hue[0], sat[0], val[0]),
                new Scalar(hue[1], sat[1], val[1]), out);
    }




}

